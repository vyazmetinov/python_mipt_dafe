# Домашнее задание 1

## Порядок оценивания

- Работу необходимо сдать в срок, установленный семинаристом, иначе работа засчитана не будет;
- Студенты, сдавшие работу в срок, допускаются к очной защите домашнего задания. Дата и время очной защиты устанавливается семинаристом заранее;
- Во время очной защиты студенту необходимо объяснить свои решения семинаристу и ответить на его дополнительные вопросы;
- Во время очной защиты семинарист запускает выполнение вашего решения на закрытом наборе тестов. Если хотя бы один из тестов не пройден, семинарист отправляет вас на доработку решения. Каждое замечание о доработке сопровождается штрафом в 1 балл;
- Во время очной защиты семинарист может обратить внимание на неправильное оформление работы и попросить исправить недочет. Каждое замечание об оформлении сопровождается штрафом в размере 0.1 балла;
- Во время очной защиты семинарист может обратить внимание на неоптимальность решения и попросить исправить недочет. Каждое замечание о неэффективности сопровождается штрафом в размере 0.5 балла;
- Если вы будете уличены в списывании или пособничестве списыванию, ваша работа аннулируется;
- Если работа не была сдана в момент проведения устной сдачи, работа на засчитывается и оценивается в 0 баллов;
- Максимальный возможный балл за задание - 10, минимальный - 0;

**Советы**:

- Уделите особое внимание самостоятельной проверке правильности решения, чтобы избежать штрафов;
- Старайтесь решать задачу наиболее эффективным способом: использовать подходящие структуры данных, избегать лишних вызовов функций и нерационального использования памяти;
- Ваша работа должна быть хорошо оформлена: все объекты должны быть именованы в соответствии с соглашениями Python, все имена должны быть осмыслены и понятны, между операторами должны находиться отступы и т.д.. Проверка оформления будет осуществляться с помощью [`flake8`](https://flake8.pycqa.org/en/latest/). Конфигурация `flake8`, которая будет использована для проверки, находится в корне репозитория в файле [`.flake8`](./../../../.flake8). Вы можете проверить правильность оформления вашей работы заранее;

## Задача 1. DAU, WAU, MAU

**Задача**

В коммерческой разработки существует большое количество различных метрик, позволяющих отслеживать активность пользователей. Одними из таких метрик являются метрики **Day Active Users** (DAU), **Week Active Users** (WAU) и **Month Active Users** (MAU) - число активных пользователей за определенный промежуток времени (день, неделю и месяц, соответственно). Под активными пользователями понимаются уникальные пользователи, которые пользовались нашим продуктом хотя бы один раз в обозначенный период времени. Важно, что пользователи являются уникальными. Т.е. если мы измеряем **DAU** и в течении текущего дня нашим приложением пользовался один и тот же пользователь, пусть и несколько раз, **DAU** будет равно 1.

Логика расчета метрик **DAU**, **WAU** и **MAU** совпадает, отличается лишь число дней, для которого происходит накопление уникальных пользователей. Обобщая эту логику еще сильнее, мы можем реализовать специальный объект, с помощью которого мы бы имели возможность подсчитывать число активных пользователей нашего продукта за произвольный промежуток времени. Ваша задача - реализовать такой объект.

В файле [`metrics.py`](./metrics.py) содержится заготовка класса `PeriodActiveUsers`. Именно этот класс мы будем использовать для расчета числа активных пользователей за определенный период времени. Приведем некоторые требования к функционалу класса:
- `Инициализация`. При создании экземпляра класса `PeriodActiveUsers` пользователю необходимо передать параметр `accumulation_period` - период времени, для которого будет вычисляться число уникальных пользователей. Ожидается, что `accumulation_period` будет целым числом, большим единицы, однако допустимо передавать любой объект, который может быть округлен и преобразован в целое число с помощью вызова встроенной функции `round()`. Если переданный объект несовместим с вызовом функции `round()`, необходимо возбудить исключение `TypeError`. Если после использования функции `round()` с переданным объектом было получено число, меньшее 1, необходимо возбудить исключение `ValueError`.
- `add_active_users_for_curr_day()`. С помощью этого метода вы можете передать последовательность `UUID` пользователей, которые пользовались сервисом в текущий день.
- `unique_users_amount`, атрибут, в котором хранится число уникальных пользователей, посещавших наш ресурс за последние `accumulation_period` дней. Иначе говоря, в атрибуте `unique_users_amount` хранится актуальное значение метрики.
- `accumulation_period`, атрибут, период времени, для которого будет вычисляться число уникальных пользователей.

**Примеры использования**

**Пример 1**
```python
from uuid import UUID
from metrics import PeriodActiveUsers


pau = PeriodActiveUsers(accumulation_period=1)
pau.add_active_users_for_curr_day(
    [
        UUID("2509a9eb-2422-4b83-8911-f780eea815bb"),
        UUID("f52fc9b2-2ff2-4419-9f07-22267946b46e"),
    ],
)
assert pau.unique_users_amount == 2
```

**Пример 2**
```python
from uuid import UUID
from metrics import PeriodActiveUsers


pau = PeriodActiveUsers(accumulation_period=3)
pau.add_active_users_for_curr_day(
    [
        UUID("52d6f353-4dd3-421b-b1c4-c35d2ae9ad66"),
        UUID("3f06aef7-bf3a-41f8-b571-3453a3b27aa9"),
        UUID("b6595baa-a23a-4e22-8656-079f84c7c3a4"),
        UUID("52d6f353-4dd3-421b-b1c4-c35d2ae9ad66"),
        UUID("52d6f353-4dd3-421b-b1c4-c35d2ae9ad66"),
        UUID("b6595baa-a23a-4e22-8656-079f84c7c3a4"),
    ],
)
assert pau.unique_users_amount == 3
```

**Вопросы для размышления**

- Почему мы используем именно класс для реализации данного функционала? Возможно ли сделать это иначе?
- Что является состоянием объекта для подсчета метрики?

## Задача 2. LRU

**Задача**

Выполнение некоторых алгоритмов, даже при учете оптимальной реализации, может потребовать большого количества времени, поэтому вычисления, реализуемые с помощью данного алгоритма, будут стоить очень дорого (и в смысле времени, и в смысле денежных средств). Можно попытаться решить эту проблему несколькими способами. Например, можно попытаться оптимизировать реализацию алгоритма, в надеже на то, что это сильно увеличит быстродействие. Однако, далеко не всегда это возможно. Поэтому инженерное сообщество стало думать о том, как уменьшить расходы на вычисления путем сокращения вызовов функций.

Самый простой способ реализации такого подхода - словарь, который бы хранил пары вида `{func_agrs: func_result}`. Тогда при вызове вычислительно дорогой функции, мы сначала проверим, есть ли результат вычисления данной функции с переданными параметрами в словаре, и если он есть - просто вернем это значение. Если результата нет, то нам придется вычислить его, а затем поместить в словарь, чтобы при последующих вызовах функции с данными параметрами, нам бы не пришлось выполнять уже проделанные вычисления.

Однако, данный подход обладает существенным минусом - бесконечный рост словаря. Именно поэтому инженерное сообщество пыталось придумать эффективный способ ограничения числа запоминаемых значений. Один из таких способов - это алгоритм `LRU cache`. **LRU** - сокращение от английского *Least Recent Used*. Идейно алгоритм работает следующим образом:
- у нас имеется некоторый словарь ограниченного размера;
- у каждой пары в словаре есть свой приоритет на удаление: чем дольше не использовалась какая-либо пара, тем больше ее приоритет на удаление;
- если для данного набора параметров, переданных во время вызова функции, в словаре имеются данные, то мы используем данные из словаря и понижаем приоритет на удаление использованной пары до минимального;
- если для данного набора параметров, переданных во время вызова функции, в словаре нет данных, то мы вызываем саму функцию, а результат сохраняем в словарь с наименьшим приоритетом на удаление;
- если размер словаря превышает установленные ограничения, мы удаляем из него пару с наибольшим приоритетом на удаление;

Логика в том, что мы пытаемся сохранить в словаре часто используемые значения, и избавиться от значений, которые используются редко. Отсюда и название алгоритма.

Итак, ваша задача - реализовать алгоритм `LRU cache` в виде параметризованного декоратора `lru_cache` для реализации возможности добавления кеша к различным функциям. Заготовка декоратора находится в файле [`cache.py`](./cache.py).

Параметром декоратора является целое число `capacity` - максимально возможный размер кеша. Ожидается, что `capacity` будет целым числом, большим единицы, однако допустимо передавать любой объект, который может быть округлен и преобразован в целое число с помощью вызова встроенной функции `round()`. Если переданный объект несовместим с вызовом функции `round()`, необходимо возбудить исключение `TypeError`. Если после использования функции `round()` с переданным объектом было получено число, меньшее 1, необходимо возбудить исключение `ValueError`.

Все операции с кешем должны работать в среднем за $O(1)$ (за константное время, т.е. время выполнения операции с кешем не должно зависеть от размера кеша).

**Допущение**: В рамках данной задачи считаем, что все аргументы функции - хешируемые объекты.

**ВАЖНО**: в Python существует готовый декоратор `lru_cache`, который находится в модуле `functools`. Использование этого декоратора, как и любых других готовых решений - **ЗАПРЕЩЕНО**. Такие решения будут оценены в 0 баллов. Вам необходимо реализовать алгоритм **САМОСТОЯТЕЛЬНО**.

**Пример использования**

```python
from cache import lru_cache


@lru_cache(capacity=2)
def get_greeting(name: str) -> str:
    greeting = f"Hello, {name}!"
    print(f"call func for name: {name}")

    return greeting


print(get_greeting("Mr.White"))
print(get_greeting("Mike"))
print(get_greeting("Mr.White"))
print(get_greeting("Saul Goodman"))
print(get_greeting("Mr.White"))
print(get_greeting("Mike"))
```

**Вывод**
```console
call func for name: Mr.White
Hello, Mr.White!
call func for name: Mike
Hello, Mike!
Hello, Mr.White!
call func for name: Saul Goodman
Hello, Saul Goodman!
Hello, Mr.White!
call func for name: Mike
Hello, Mike!
```
