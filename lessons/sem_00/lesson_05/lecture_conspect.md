# Последовательности: строки

**Содержание:**

- [Строки](#строки);
- [Мультистроки и специальные символы](#мультистроки-и-специальные-символы);
- [Строки как последовательности](#строки-как-последовательности);
- [Логические операции](#логические-операции);
- [Коды символов](#коды-символов);
- [Методы манипуляции с регистром](#методы-манипуляции-с-регистром);
- [Методы проверки символов](#методы-проверки-символов);
- [Методы очистки строк](#методы-очистки-строк);
- [Методы разделения и объединения](#методы-разбиения-и-объединения);
- [Методы для работы с подстроками](#методы-для-работы-с-подстроками);

## Строки

Строками в Python называется неизменяемая последовательность, состоящая из символов и используемая для представления некоторой текстовой информации. В отличие от многих других языков программирования, в Python нет специального типа данных для хранения единичных символов. Поэтому элементами строк являются строки единичной длины, т.е. строки, состоящие из одного символа. Максимальная длина строки ограничена количеством доступмной памяти. Строки обладают достаточно широким функционалом, поэтому имеет смысл рассматривать строки отдельно от прочих последовательностей.

Строка может быть создана с помощью вызова встроенного объекта `str()`. На вход `str()` принимает любой объект, поддерживающий конвертацию в строку. Все встроенные типы данных Python имеют строковые представления и поддерживают конвертацию в строку. Ниже приведены примеры конвертации в строки изученных ранее типов данных:

```python
# конвертация логического типа
>>> str(True)
'True'

# конвертация целых чисел
>>> str(42)
'42'

# конвертация float
>>> str(3.14)
'3.14'

# конвертация списка
>>> str([1, 2, 3])
'[1, 2, 3]'

# конвертация кортежа
>>> str((4, 5, 6))
'(4, 5, 6)'

# конвертация строки
>>> str("abc")
'abc'

# пустая строка
>>> str()
''
```

Также объект строки может быть создан из строкового литерала. Строковый литерал представляет собой последовательность символов, заключенную в двойные `""` или одинарные `''` кавычки. Выбрав тип ковычек, для определения строкового литерала, вы можете спокойно использовать второй тип кавычек внутри вашего строкового литерала. Вы также можете использовать кавычки того же типа, что и тип кавычек, использованный для определения стрового литерала, внутри этого строкового литерала. Для этого символ кавычек внутри строкового литерала должен быть *экранирован*. Т.е. перед символом кавычки должен идти символ обратного слеша `\`.

*Примеры строковых литералов*:
```python
# одинарные кавычки
'this is string literal'
# двойные кавычки
"this is string literal too"
# включение кавычек другого типа
"I'm iron man"
# включение кавычек того же типа
'I\'m iron man'
```

Несколько строковых литералов могут быть объеденены в один строковый литерал способом, аналогичном тем же способам, что и объединение нескольких физических строк в одну логическую. Записанные друг за другом строковые литералы разделенные произвольным числом пробелов (в том числе и нулем) также будут объединены в один строковый литерал.

*Примеры объединения строковых литералов*:
```python
# объединение с помощью \
>>> string = "this is one " \
    "single string"
>>> string
'this is one single string'

# python-way объединение
>>> string = (
        "this is one "
        "single string"
    )
>>> string
'this is one single string'

>>> "abc"  "def""ghi" "j"
'abcdefghij'
```

[[К содержанию](#последовательности-строки)]

## Мультистроки и специальные символы

При некоторых сообщений в консоль часто бывает полезным разделить сообщение на несколько физических строк, чтобы уложиться в определенную длину строки и сдлать дружелюбный интерфейс командной строки. В простейшем случае решить эту задачу можно было бы последовательным вызовом `n` функций `print`, где `n` - это число строк, которые необходимо вывести. Каждый `print` бы в свою очередь печатал бы определенную строку сообщения. Однако данный подход является достаточно утомительным и муторным. Вместо этого, мы можем определить строковый литерал, содержащие специальную последовательность символов для перехода на новую строку `\n`. Выглядел бы такой литерал следующим образом:

```python
>>> string = (
        "string 1\n"
        "string 2\n"
        "string 3"
    )
>>> print(string)
string 1
string 2
string 3
```

Помимо специальной последовательности символов `\n`, которую вы можете включить в строковый литерал для разбиения литерала на несколько физических строк во время вывода, существует ряд других специальных последовательностей символов. Ниже приведена таблица частоиспользуемых специальных последовательностей символов.

|Последовательность символов|Значение|
|---|---|
| \\ |Экранирование символов строки, например, кавычек того же типа, что и тип кавычек, использованных для определения строкового литерала|
|\n|Переход на новую строку|
|\t|Таб|
|\r|Возврат каретки в начало строки|

С последовательностями `\` и `\n` мы познакомились в примерах выше. Рассмотрим примеры использования последовательностей `\t` и `\r`:

```python
# использование \t
>>> string = "word\ttabbed word"
>>> print(string)
word    tabbed word

# использование \r
>>> string = "world\roverriden world"
>>> print(string)
overriden world
```

Помимо использования способа с использованием последовательности `\n` существует еще один способ создания мульти строк. Для этого используются строковые литералы, заключенные в последовательности трех кавычек: `'''` или `"""`. Каждая физическая строка мультистрокового литерала прив выводе будет отображаться как отдельная строка. Чтобы объединить две физические строки мультистрокового литерала, можно использовать символ `\`. В отличие от рассмотренного выше способа создания мультистроки, при создании мультистрокового литерала использование комментариев на каждой строке литерала запрещено.

*Пример мультистрокового литерала:*
```python
# двойные кавычки
>>> print(
        """\
        line1
        line2\
        """
    )
line1
line2

# одинарные кавычки
>>> print(
        '''\
        line1
        line2\
        '''
    )
line1
line2
```

Обычно мультистроки используются в качестве *докстрингов* (англ. *docstring*) для различных объектов. В этом случае тело объекта должно начинаться с мультистроки, содержащей пояснения о назначении данного объекта. Примером использования мультистрок для создания докстрингов может являться документирование поведения функции:

```python
def do_staff(param1: int, param2: str = "") -> None:
    """
    Do some really usefull staff.

    Args:
        param1: first parameter - integer.
        param2: second parameter - string.
            Default - empty string.

    Returns:
        None.
    """
    ...
```

[[К содержанию](#последовательности-строки)]

## Строки как последовательности

Посколько строки являются последовательностями, они поддерживают все опеарции свойственный последовательностям.

### Определение длины

Строки поддерживают использование со встроенной функцией `len()`. В случае строк `len()` вернет целое число - длину строки, или, иначе говоря, количество символов, содержащееся в данной строке.

*Примеры использования `len()`*:
```python
# длина непустых строки
>>> len("abcdefg")
7

# пробелы тоже считаются
>>> len("abc def")
7

# длина пустой строки всегда 0
>>> len("")
0
```

### Конкатенация и повторение

Строки поддерживают операции конкатенации и повторения. Рассмотрим примеры использования данных операций:

```python
>>> string1 = "abc"
>>> string2 = "def"

# конкатенация
>>> string1 + string2
'abcdef'

# конкатенация в составном присваивании
>>> string1 += string2
>>> string1
'abcdef'

# повторение
>>> string2 * 3
'defdefdef'

# повторение в составном присваивании
>>> string2 *= 3
>>> string2
'defdefdef'
```

### Оператор in

С помощью оператора `in` в Python реализуется возможность проверки того, что левая строка является подстрокой правой строки. 

**Замечание**: строка `a` называется подстрокой `b`, если в `b` присутствует непрерывная последовательность символов, равная `a`.

*Примеры*:
```python
>>> "bcd" in "abcdef"
True

>>> "ace" in "abcdef"
False

>>> "" in "abc"
True
```

### Индексирование

Поскольку строки - неизменяемы последовательности, они поддерживают чтение элементов с использованием целочисленных индексов. Также строки поддерживают использование срезов.

*Примеры индексации строк*:
```python
string = 'what a wonderful world'

string[1]       # == h
string[-1]      # == d
string[::-1]    # == dlrow lufrednow a tahw
string[2:8]     # == at a w
```

[[К содержанию](#последовательности-строки)]

## Логические операции

Строки поддерживают выполнения логических операций. Сравнение строк осуществляется в соответствии с [лексикографическим порядком](https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D0%BA%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA) следования строк. В качестве алфавита для упорядочивания строк используются символы поддерживаемые кодировкой Unicode, расположенные в порядке, описываемые этой кодировкой. Т.е. строка `a` является больше строки `b`, если строка `a` следует за строкой `b` в лексикографическом порядке следования строк.

```python
>>> "abc" == "def"
False
>>> "abc" != "def"
True
>>> "abc" < "def"
True
>>> "abc" <= "def"
True
>>> "abc" > "def"
False
>>> "abc" >= "def"
False
```

[[К содержанию](#последовательности-строки)]

## Коды символов

Как говорилось выше в Python нет отдельного типа данных для представления единичных символов. Отдельные символы представляются строками единичной длины. В Python существуют функции для работы с отдельными символами. Одна из таких функций - это функция встроенная `ord()`, которая позволяет получить целочисленный код символа в кодировке Unicode.

**Важно**: несмотря на то, что функция `ord()` принимает на вход строку, длина строки должна быть равна единице, иначе интерпретатором будет возбуждено исключений `TypeError`.

Обратная к функции `ord()` функция - функция `chr()`, которая позволяет получить строку единичной длины - символ, соответствующий переданному целочисленному число - Unicode-коду.

*Примеры использования*:
```python
# использование ord()
>>> ord("a")
97

# использование chr()
>>> chr(97)
'a'

# неверное использование ord()
>>> ord("hello")
TypeError: ...
```

[[К содержанию](#последовательности-строки)]

## Методы манипуляции с регистром

Строки обладают внушительным количеством методов. Описание всех этих методов превратилось бы в пересказывание документации, поэтому в рамках данного занятия будут описаны часто используемые методы с основными сценариями их применения.

Первой группой методов являются методы манипуляции с регистром. Методы манипуляции с регистром могут быть очень полезны при подготовке некоторого текста к дальнейше обработке. Например, мы можем реализовывать некоторый сервис, который требует от пользователей регистрации, после чего предоставляет доступ к контенту. При регистрации для нас существенно, чтобы имена пользователей были уникальны, причем регистр в записи имени не учитывается. В этом случае нам отлично подойдут методы строк для манипуляции с регистром.

В рамках данного занятия мы рассмотрим следующие методы: `upper()`, `lower()` и `title()`. Поскольку строки - это немодифицируемый тип данных, все этим методы возвращают новые объекты типа строка. Метод `upper()` позволяет перевести все символы строки в символы нижнего верхнего, `lower()` - противоположность `upper()`. `title()` возвращает строку, каждое слово в которой написано с заглавной буквы.

*Примеры использования*:
```python
# использование upper
>>> 'Gvido Van Rossum'.upper()
'GVIDO VAN ROSSUM'

# использование lower
>>> 'Gvido Van Rossum'.lower()
'gvido van rossum'

# использование title
>>> 'gvido van rossum'.title()
'Gvido Van Rossum'
>>> 'GVIDO VAN ROSSUM'.title()
'Gvido Van Rossum'
```

### Практический пример использования методов

Наверное, самый очевидный пример использования методов манипуляции с регистром - сортировка слов в лексикографическом порядке. Поскольку при сортировки учитываются именно Unicode-коды символов, попытка отсортировать список слов в разном регистре приведет к очевидному, но некорректному, с точки зрения естественного языка, результату:

*Некорректный результат дефолтной сортировки*:
```python
words = [
    'CIA', 'border', 'Alabama', 'apple',
    'Appel', 'zero', 'two', 'Paris',
]
words.sort()

print(words)
# [
#   'Alabama', 'Appel', 'CIA', 'Paris',
#   'apple', 'border', 'two', 'zero'
# ]
```

Однако, мы бы все же хотели увидеть именно слова, отсортированные согласно английскому алфавиту. Чтобы исправить данное недоразумение, мы можем перевести все слова в один регистр и только потом отсортировать:

```python
words = [
    'CIA', 'border', 'Alabama', 'apple',
    'Appel', 'zero', 'two', 'Paris',
]
words.sort(key=str.upper)

print(words)
# [
#   'Alabama', 'Appel', 'apple', 'border',
#   'CIA', 'Paris', 'two', 'zero'
# ]
```

Теперь мы имеем корректный с точки зрения английского языка результат.

[[К содержанию](#последовательности-строки)]

## Методы проверки символов

Методы проверки символов позволяют определить, состоит ли данная строка из символов определенного типа, или нет. Например, состоит ли данная строка исключительно из букв или нет. Методы проверки символов возвращают значения логического типа данны: `True`, если строка состоит только из символов определенного типа, `False` - иначе. Рассмотрим некоторые из методов данной категрии подробнее:

|Метод|Описание|
|---|---|
| `isalpha()` | Возвращает `True`, только если строка состоит исключительно из алфаметрических символов, т.е. все символы, являются символами алфавита, а сама строка не является пустой|
| `isdigit()` | Возвращает `True`, только если строка состоит исключительно из цифровых символов, т.е. все символы, являются десятичными цифрами, а сама строка не является пустой |
| `isalnum()` | Возвращает `True`, только если строка состоит исключительно из алфаметрических b цифровых символов, а также не является пустой |
| `isspace()` | Возвращает `True`, только если строка состоит исключительно из символов табуляции, а также не является пустой |
| `isupper()` | Возвращает `True`, только если строка состоит исключительно из символов в верхнем регистре, а также не является пустой |
| `islower()` | Возвращает `True`, только если строка состоит исключительно из символов в нижнем регистре, а также не является пустой |

*Примеры проверки символов*:
```python
# пример использования isalpha
>>> "AbCdeFg".isalpha()
True
>>> "12345".isalpha()
False
>>> "".isalpha()
False

# пример использования isdigit
>>> "AbCdeFg".isdigit()
False
>>> "12345".isdigit()
True
>>> "".isdigit()
False

# пример использования isspace
>>> "AbCdeFg".isspace()
False
>>> " \t\n".isspace()
True
>>> "".isspace()
False

# проверка соответствия регистру
>>> "Abcdef".isupper()
False
>>> "ABCDEF".isupper()
True
>>> "Abcdef".islower()
False
>>> "abcdef".islower()
True
```

Методы проверки символов могут быть использованы для реализации различных алгоритмов валидации входных текстовых данных. Например, вы можете использовать метод `isalnum` для валидации имен пользователей, в случае если допустимое имя пользователя может содержать только буквы английского алфавита и цифры.

[[К содержанию](#последовательности-строки)]

## Методы очистки строк

Зачастую перед работой с различной текстовой информацией требуется осуществить очистку текст от нежелательных и неинформативных данных. Примером может служить удаление ненужных ведущих пробелов. Или удаление некоторых служебных последовательностей символов, наличие которых для корректного использования текста больше не требуется. В таблице ниже приведены основные методы, позволяющие избавиться от ненужных последовательностей символов, или заменить их на необходимые вами последовательности символов. Все описанные методы возвращают новую очищенную строку в качестве результата.

|Метод|Описание|
|---|---|
| `replace(old, new, count=-1)` | Заменяет `count` вхождений подстроки `old` на строку `new`. Если `count == -1`, заменяет все вхождения подстроки `old` на строку `new` |
| `strip()` | Удаляет переданною последовательность символов с правой и с левой стороны строки. Последовательности символов справа и слева удаляется до тех пор, пока не будет встречена последовательность символов, отличная от удаляемой |
| `lstrip()` | То же самое, что `strip()`, только последовательности удаляются слева |
| `rstrip()` | То же самое, что `strip()`, только последовательности удаляются справа |

*Примеры очистки строк*:
```python
>>> "aaaabbbaabbaaa".replace("a", "")
'bbbbb'

>>> "aaaabbbaabbaaa".strip("a")
'bbbaabb'

>>> "aaaabbbaabbaaa".lstrip("a")
'bbbaabbaaa'

>>> "aaaabbbaabbaaa".rstrip("a")
'aaaabbbaabb'
```

[[К содержанию](#последовательности-строки)]

## Методы разбиения и объединения

Иногда текстовое сообщение может модержать отдельные части, требующие отдельной обработки и анализа. Т.е. для корректной обработки строки требуется разбить ее на несколько частей. Нередка и обратная ситуация, когда нам необходимо сформировать строку из большого количества частей, хранящихся в некоторой коллекции. Для решения этих проблем у строк существует два метода: `split()` и `join()`.

Метод `split()` позволяет разбить строку на части, используя полученную последовательность символов в качестве разделителя между частями. Результатом выполнения метода `split()` является список строк, полученных после разделения. По умолчанию `split()` осуществляет разбиение по символам табуляции.

Метод `join()` наоборот позволяет объединить строки из переданного итерируемого объекта в одно строку. В качестве последовательности-связки между частями `join()` использует ту строку, у которой он был вызван.

*Примеры разбиений и объединений*:
```python
# дефолтное разбиение
>>> "  aba  b".split()
['aba', 'b']

# указания разделяющей последовательности
>>> "  aba  b".split("a")
['  ', 'b', '  b']

# объединение
>>> "-".join(("one", "two"))
'one-two'
```

[[К содержанию](#последовательности-строки)]

## Методы для работы с подстроками

Одной из важнейших задач при работе со строками является задача на поиск подстроки в заданной строке. Подробнее об алгоритмах поиска подстроки вам будет рассказано на курсе Алгоритмы и Структуры данных. В рамках нашего курса вам достаточно знать, что строки в Python реализуют методы для поиска подстроки, а также методы для проверки равно ли значение префикса/суффикса переданному значению. В таблице ниже приведена более подробная информация о методах данного типа.

|Метод|Описание|
|---|---|
| `startswith()` | Позволяет определить, является ли переданная строка префиксом данной строки или нет. Также имеет возможность указать подстроку данной строки, для которой необходимо произвести проверку. Возвращает булево значение |
| `endswith()` | Позволяет определить, является ли переданная строка суффиксом данной строки или нет. Также имеет возможность указать подстроку данной строки, для которой необходимо произвести проверку. Возвращает булево значение |
| `find()` | Возвращает индекс первого вхождения заданной подстроки в данной строке. Поиск осуществляется справа налево. Если данная строка не содержит заданной подстроки, возвращает `-1`. Также имеет возможность указать подстроку данной строки, для которой необходимо произвести поиск |
| `rfind()` | То же самое, что и `find()`, только поиск осуществляется справа налево |
| `index()` | То же самое, что и `find()`, только в случае, если подстрока не будет найдена, вернет ошибку |
| `rindex()` | То же самое, что и `rfind()`, только в случае, если подстрока не будет найдена, вернет ошибку |

*Примеры работы с подстроками*:
```python
# startswith / endswith
>>> "hello world".startswith('hello')
True
>>> "hello world".startswith('hello', -12, -5)
True
>>> "hello world".startswith('hello', 6, 9)
False

>>> "hello world".endswith('world')
True
>>> "hello world".endswith('world', 6)
True
>>> "hello world".endswith('world', 6, 9)
False

# find / rfind
>>> "banana".find("na")
2
>>> "banana".find("na", 3)
4
>>> "banana".find("na", 0, 3)
-1

>>> "banana".rfind("na")
4
>>> "banana".rfind("na", 0, 5)
2
>>> "banana".rfind("na", 0, 3)
-1

# index / rindex
>>> "banana".index("na")
2
>>> "banana".index("na", 3)
4
>>> "banana".index("na", 0, 3)
ValueError: substring not found

>>> "banana".rindex("na")
4
>>> "banana".rindex("na", 0, 5)
2
>>> "banana".rindex("na", 0, 3)
ValueError: substring not found
```

[[К содержанию](#последовательности-строки)]
