# Структура языка. Логический тип данных.

**Содержание:**
- [Строки и отступы](#строки-и-отступы);
- [Инструкции](#инструкции-statements);
- [Токены](#токены);
- [Объекты Python](#объекты-python);
- [Переменные и ссылки](#переменные-и-ссылки);
- [Виды присваивания](#виды-присваивания);
- [Логический тип данных](#логический-тип-данных);
- [Операции над объектами логического типа данных](#операции-над-объектами-логического-типа-данных);
- [Операторы and, or, not](#операторы-and-or-not);
- [Некоторые управляющие конструкции](#некоторые-управляющие-конструкции);

## Строки и отступы

Любая программа, написанная на языке Python, представляет собой набор текстовых файлов с расширением `.py`. В файлах с расширением `.py` записывается исходный код. Исходный код представляет собой последовательность **логических строк**, каждая из которых состоит из одной или нескольких **физических строк**, т.е. строк текстового файла, завершающихся символом конца строки. Исходный код может не содержать ни одной логической строки. В этом случае файл с исходным кодом будет пустым.

Исходный код может содержать комментарии. Комментарием считается часть строки, расположенная после символа `#`. Разработчики используют комментарии, чтобы добавлять пояснения к непонятным блокам кода. При исполнении кода программы комментарии игнорируются интерпретатором Python.

**Важно**: не пренебрегайте и не злоупотребляйте использованием комментариев. Лучший способ коммуникации с другими разработчиками - это чистый код, поэтому не стоит оставлять комментарии для каждой строки, особенно для очевидных строк. Однако стоит добавлять комментарии для тех строк и блоков кода, которые являются трудными для понимания.

*Пример, как надо использовать комментарии:*
```python
# максимальная дальность обзора РЛС в морских милях
# значение взято из протокола использования РЛС, с.3 таб.1
distance_max = 72 * 1852
```

*Пример, как не надо использовать комментарии:*
```python
distance_max = 72 * 1852 # определили максимальную дальность
```

Также исходный код может содержать пустые строки. Пустыми называются строки, которые содержат только символы табуляции, комментарии или не содержат ни одного символа, кроме символа конца строки. Пустые строки используются для повышения читаемости кода программы. С помощью пустых строк разработчики разделяют логические блоки кода.

**Важно**: не пренебрегайте использованием пустых строк. Грамотное использование пустых строк позволяет значительно увеличить читабельность вашего кода.

*Пример, как не стоит делать*:
```python
if number % 2 == 0:
    number_type = "even"
else:
    number_type = "odd"
print(f"I got {number_type} number")
```

*Пример, как стоит делать:*
```python
if number % 2 == 0:
    number_type = "even"

else:
    number_type = "odd"

print(f"I got {number_type} number")
```


Для людей, использовавших C или C++ в качестве основного языка программирования, будет необычен тот факт, что конец строки определяется символом перехода на новую строку, а не требует явного обозначения с помощью специальной последовательности символов (в C и C++ строки завершаются символом `;`). Как и в C++ слишком длинные физические строки могут быть разбиты на несколько физических строк и объединены в одну логическую с помощью символа `\`. Однако этот стиль не рекомендуется, поскольку в Python присутствует более элегантное python-way решение. Интерпретатор Python автоматически объединяет физические строки, находящиеся в круглых `()`, квадратных `[]` и фигурных `{}` скобках, в одну логическую строку. Так что не гнушайтесь использования этого механизма для повышения качества вашего кода.

*Пример различных строк:*
```Python
# физическая строка
light_velocity = 3e8

# логическая строка
very_long_string = "this is very very very long string so long " \
"so you need to postpone its part to the next physical line"

# python-way логическая строка
another_long_string = (
    "this is very very very long string so long "
    "so you need to postpone its part to the next physical line"
)
```

В отличие от многих других языков программирования, которые используют скобки или специальные ключевые слова для обозначения блоков кода, Python использует отступы. Отступы - это единственный способ обозначить блок кода. Каждая логическая строка в вашей программе имеет свой уровень отступа. Блок кода - это непрерывная последовательность логических строк, имеющих одинаковый уровень отступа. Логическая строка с меньшим отступом завершает блок кода.

[[К содержанию](#структура-языка-логический-тип-данных)]

## Инструкции (statements)

Поднявшись выше на один уровень абстракции, можно рассматривать исходный код, как набор *простых* и *составных* инструкций (англ. *statements* и *compound statements*).

**Простые инструкции** состоят из одной логической строки. Примерами простых инструкций являются выражения (англ. *expressions*), т.е. конструкции, порождающие некоторые значения. Также в качестве примера простой инструкции можно привести операцию привязки переменной к значению.

*Пример простой инструкции*:
```python
# операция привязки переменной к значению - простая инструкция
light_velocity = 3e8
```

**Составными инструкциями** называются инструкции, которые содержат в себе несколько других инструкций и осуществляют контроль за их выполнением. Составные инструкции имеют не менее одного **положения** (англ. *clause*). Положения, принадлежащие к данной составной инструкции, имеют одинаковый отступ. Каждое положение обладает **хедером** (англ. *header*). Хедер осуществляет контроль исполнения всей инструкции. Хедер обязательно начинается с ключевого слова и завершается двоеточием `:`. За хедером следует **тело положения** - набор инструкций, каждая из которых имеет один и тот же уровень отступа и больший уровень отступа в сравнении с хедером.

*Пример сложной инструкции*:
```python
# первое положение сложной инструкции
if number % 2 == 0: # хедер первого положения
    # тело первого положения
    number_type = "even"

# второе положение сложной инструкции
else: # хедер второго положения
    # тело второго положения
    number_type = "odd"

# этот код не относится к сложной инструкции
print(f"I got {number_type} number")
```

[[К содержанию](#структура-языка-логический-тип-данных)]

## Токены

Интерпретатор Python разбивает каждую логическую строку на последовательность языковых единиц, также известных, как **токены**. Существуют следующие виды токенов: 
- идентификаторы
- разделители
- литералы
- операторы
- ключевые слова

Некоторые токены необходимо разделять между собой пробелами. Например, между идентификаторами и ключевыми словами обязательно должны содержаться пробелы, иначе интерпретатор будет воспринимать такую последовательность токенов как один единственный идентификатор. Некоторые токены разделять пробелами необязательно. Например, идентификаторы и операторы.

### Идентификаторы

**Идентификатор** - это имя, которое может быть связано с некоторым объектом: функцией, классом, модулем и т.д. Идентификаторы начинаются с буквы английского алфавита или с нижнего подчеркивания `_`. За начальным символом следует сколько угодно букв, нижних подчеркиваний и цифр. Символы пунктуации недопустимы для использовании в идентификаторах.

В Python используется следующее соглашение об идентификаторах: идентификаторы переменных, функций и модулей пишутся в `snake_case` (слова написаны в нижнем регистре и разделены между собой нижними подчеркиваниями `_`), идентификаторы классов - в `PascalCase` (каждое слово написано с большой буквы, слова не разделяются между собой никакими специальными символами). Нарушение этих правил не является синтаксической ошибкой и не отслеживается интерпретатором, однако вы рискуете быть непонятыми другими разработчиками.

Некоторые идентификаторы, начинающиеся с двух нижних подчеркиваний и заканчивающиеся двумя нижними подчеркиваниями, являются специальными именами.

**Важно:** идентификаторы чувствительны к регистру. Идентификатор `my_variable` и `My_variable` - это два разных идентификатора.

*Примеры идентификаторов*:
```Python

my_variable = 5         # валидное имя
MyVariable = 6          # тоже валидное имя
_var1 = 1               # это тоже валидное имя
__len__ = 4             # и это валидное имя переменной
_2 = 2                  # и это тоже

2var = 2                # SyntaxError
my_$uper_variable = 4   # SyntaxError

```

### Разделители 

В Python используются следующие символы и комбинации символов в качестве разделителей в выражениях, литералах и для прочих целей в различных инструкциях:

```Python
(       )       [       ]       {       }
,       :       .       ;       @       =       ->
+=      -=      *=      /=      //=     %=      @=
&=      |=      ^=      >>=     <<=     **=
```

Обратите внимание, что половина разделителей, содержащихся в списке, является операторами составного присваивания (например, `+=` и `-=`). Несмотря на то, что с их помощью осуществляется выполнение определенных операций, с лексической точки зрения они считаются разделителями.

Следующие символы имеют специальные значения при использовании их в качестве частей других токенов:

```Python
'   "   #   \
```

### Литералы

**Литерал** - это прямая запись значения некоторого встроенного типа данных. Ниже приведены примеры литералов:

```Python
1                   # целое число
3.14                # число с плавающей точкой
1.0j                # комплексное число
"Hello!"            # строковый литерал
```


### Операторы

Следующие символы используются Python в качестве операторов:

```Python
+       -       *       **      /       //      %      @
<<      >>      &       |       ^       ~       :=
<       >       <=      >=      ==      !=
```

### Ключевые слова

**Ключевые слова** - это набор зарезервированных идентификаторов, которые используются в Python для специальных синтаксических конструкций. Из этого следует, что вы не можете использовать ключевое слово в качестве идентификатора для какого-либо объекта. Ключевые слова содержат только идентификаторы в нижнем регистре. Некоторые ключевые слова служат для начала составных инструкций, в то время как другие являются операторами.

Следующие идентификаторы являются ключевыми словами:
```python
False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield
```

[[К содержанию](#структура-языка-логический-тип-данных)]

## Объекты Python

Любая программа, реализованная с помощью любого языка программирования, так или иначе осуществляет работу с какими-либо данными. Python не является исключением. Для манипуляций над данными в рамках программы используется специальная абстракция, называемая **объектом**. Каждый объект Python характеризуется тремя признаками:
- идентичностью (англ. *identity*)
- типом данных
- значением

### Идентичность

Идентичность объекта Python является неизменяемой характеристикой. Работа с идентичностью объекта осуществляется при помощи встроенной функции `id()` и оператора `is`.

Функция `id()` принимает на вход объект Python (на самом деле ссылку на объект Python, но об этом мы поговорим ниже) и возвращает его идентичность. Гарантируется, что идентичности разных объектов будут разными. Идентичность объекта можно интерпретировать как адрес объекта. В случае с реализацией CPython, изучением которой мы занимаемся, `id()` возвращает адрес объекта в памяти в виде целого числа.

*Пример использования id в REPL CPython*:
```console
>>> id(5)
140723671524264
```

**Замечание**: вывод может отличаться, поскольку на разных машинах разные объекты могут находиться в ячейках памяти с отличными друг от друга адресами.

Оператор `is` является бинарным оператором и позволяет проверить, обладают ли операнды одной и той же идентичностью или нет. Иначе говоря, с помощью бинарного оператора `is` можно проверить являются ли его операнды одним и тем же объектом. Результатом использования `is` является булево значение (о булевых значениях будет сказано ниже). Такая проверка может потребоваться в случае, если один из операндов - это некоторое значение-синглтон.

**Замечание**: объект-синглтон - это объект, который представлен единственным экземпляром в любой момент выполнения программы.

Примером использование оператора `is` может считаться сравнение любого объекта со специальным объектом-синглтоном `None`. `None` часто используется для обозначения отсутствия значения, в качестве значений по умолчанию, а также в качестве возвращаемого значения функциями, у которых отсутствует явное описание возвращаемого значения (об этом мы поговорим в одном из следующих занятий).

*Пример использования is в REPL CPython*:
```console
>>> print() is None

True
```

Данный пример показывает, что возвращаемое значение встроенной функции `print` - это `None`.

### Тип данных

Следующая характеристика объекта - это его тип данных. Тип данных определяет множество допустимых операций для данного объекта, а также множество допустимых значений. Как и идентичность, тип Python-объекта не изменяется. Для работы с типами объектов используется встроенный объект `type`.

С помощью объекта `type` можно узнать тип Python-объекта.

*Пример определения типа объекта с помощью `type`*:
```console
>>>type(None)
<class 'NoneType'>

>>>type(None).__name__
'NoneType'
```

Это может быть полезно для проверки типа данных интересующих объектов в процессе отладки, для логгирования или для использования в объектах-фабриках. Также, используя комбинацию `type`и `is` вы можете проверить, является ли Python-объект объектом требуемого типа данных.

*Пример проверки типа данных через `type` и `is`*:
```console
>>>bool_flag = True
>>>type(bool_flag) is bool
True
```

Однако проверять соответствие типов таким образом не рекомендуется. Для проверки того, что определенный объект является объектом определенного типа данных в Python используется специальная функция `isinstance`. В качестве аргументов функция принимает объект Python и тип данных, принадлежность к которому требуется проверить. Перепишем предыдущий пример с помощью `isinstance`:
```console
>>>bool_flag = True
>>>isinstance(bool_flag, bool)
True
```

### Значение

Последняя характеристика объекта - это его значение. Значение объекта - это и есть те данные, которыми мы манипулируем в нашей программе.

### Изменяемые и неизменяемы типы данных

Значения объектов некоторых типов данных не могут изменяться в процессе выполнения программы. Такие типы данных называются **неизменяемыми** типами данных. Примером неизменяемого типа данных является тип данных `bool`, т.е. логический тип данных. В противовес к неизменяемым типам данных в Python также существуют **изменяемые** типы данных. Значения объектов изменяемых типов данных могут изменять свое значение в процессе выполнения программы. Примером изменяемого типа данных является список - `list`.

[[К содержанию](#структура-языка-логический-тип-данных)]

## Переменные и ссылки

Python не дает вам доступ к данным в памяти компьютера напрямую, как это происходит, например в C++. Вместо этого Python позволяет осуществлять доступ к объектам посредством ссылок. Переменные в Python - это именованные ссылки, через которые осуществляется доступ к значению объекта. Создание новой переменной в Python эквивалентно созданию новой ссылки на объект или, в случае если объект не существовал до создания переменной, созданию нового объекта и последующему созданию новой ссылки.

В отличие от Python-объектов, ссылки в Python не имеют типа данных. Т.е. на протяжении выполнения программы одна и та же переменная может использоваться для доступа к объектам разных типов данных. Например, сначала переменная используется для доступа к объекту числового типа, затем к коллекции, а в конце вообще к объекту пользовательского типа данных. В этом смысле Python является **динамически-типизируемым** языком программирования.

В Python отсутствует механизм объявления переменных, который характерен для многих языков программирования. Для того, чтобы создать переменную, вы обязательно должны ее определить. Процесс определения переменной называется **привязкой**, поскольку в процессе определения вы создаете новую ссылку и связываете ее с определенным Python-объектом. Привязка осуществляется с помощью оператора `=`. Также вы можете связать существующую переменную с новым значением. Такая операция называется операцией **перепривязки**.

Рассмотрим работу с переменными на примере:
```python
num1 = 5
num2 = num1
num1 = 6
```

После выполнения первой инструкции в памяти компьютера будет создан целочисленный объект со значением `5`, а также ссылка на этот объект, которая будет привязана к переменной `num1`. После выполнения второй инструкции новый объект в памяти создан не будет, но будет создана новая ссылка на уже существующий объект. Созданная ссылка будет связана с переменной `num2`. После выполнения первых двух инструкций в памяти будет храниться один объект целочисленного типа данных, на который указывают две ссылки, связанные с переменными `num1` и `num2`, соответственно. В третьей инструкции `num1` была перепривязана. Здесь происходит почти все то же, что происходило в первой строке листинга кода. Единственное изменение - это отвязка ссылки `num1` от объекта со значением `5` и привязка этой ссылки к созданному целочисленному объекту со значением `6`. В итоге, после выполнения этого листинга кода в памяти компьютера будет два объекта: целое число со значением `5`, на которое в программе ссылается переменная `num2`, и целое число со значением `6`, на которое ссылается переменная `num1`. 

Для лучшего понимания того, что происходит, воспользуемся оператором `is`.

*Код:*
```Python
num1 = 5
num2 = num1

print(num1 is num2)

num1 = 6
print(num1 is num2)

```
*Вывод:*
```Console
>>> True
>>> False
```

В данном примере отчетливо видно, что после определения переменной `num2`, ссылки `num1` и `num2` ссылаются на один и тот же объект в памяти (помним, что делает оператор `is`). А после перепривязки `num1`, ссылки `num1` и `num2` начинают ссылаться на два разных объекта в памяти.

[[К содержанию](#структура-языка-логический-тип-данных)]

## Виды присваивания

Как и во многих других языках программирования, привязка в Python, она же присваивание, является правоассоциативной операцией, т.е. операцией, которая выполняется справа налево. За счет этой особенности существует возможность выполнения так называемого **каскадного присваивания**:

```python
num1 = num2 = num3 = 0
```

В данном примере мы создали три переменные: `num1`, `num2`, `num3`, - которые ссылаются на один и тот же объект в памяти - целое число со значением `0`. Причем сначала был создан объект, потом ссылка `num3`, связанная с этим объектом, затем ссылка `num2`, которая также была связана с созданным объектом, и только потом была создана ссылка `num1`.

Помимо составного присваивания в Python существует **множественное присваивание**, т.е. одновременное создание переменных, которые могут ссылаться на разные объекты.

*Пример множественного присваивания*:
```python
num1, num2 = 3, 4
num1, num2 = num2, num1
```

В первой строке данного примера мы создали переменные `num1` и `num2`, значения которых равны `3` и `4`, соответственно. Во второй строке мы осуществили перепривязку переменных. Фактически во второй строке мы поменяли значения переменных друг с другом. Это возможно из-за правоассоциативности операции присваивания: сначала вычисляется правая часть, после чего осуществляется привязка переменных к вычисленным результатам.

Каскадное и множественное присваивание может оказаться полезным для компактной записи инициализации некоторых объектов их начальными значениями.

[[К содержанию](#структура-языка-логический-тип-данных)]

## Логический тип данных

Рассмотрим поближе некоторые встроенные типы данных. Одним из простейших встроенных типов данных является **логический** тип данных, или **булев** тип данных. Логический тип данных используется в качестве результатов вычислений некоторых функций, а также часто требуется в условиях управляющих конструкций. Например, выше мы видели объект логического типа данных при вычисление результата применения оператора `is`. 

Объекты логического типа данных могут принимать одно из двух значений: истина или ложь. Этим значениям соответствуют специальные объекты-синглтоны: `True` и `False`.

Любой объект Python, реализующий специальный метод `__bool__`, может быть конвертирован в объект логического типа данных с помощью вызова встроенной функции `bool()`. Все встроенные типы данных реализуют функцию `__bool__`, а следовательно поддерживают конвертацию в объект логического типа данных при помощи вызова `bool()`. Так, например, любое целое число, отличное от нуля, конвертируется в булев объект со значением `True`, ноль - в `False`. Любая непустая коллекция конвертируется в `True`, пустая - в `False`. `None` всегда конвертируется в `False`.

*Примеры конвертации объектов в логический тип данных:*
```console
>>> bool(0)
False

>>> bool(3)
True

>>> bool(-3)
True

>>> bool(0.5)
True

>>> bool([1, 2, 3])
True

>>> bool([])
False

>>> bool(None)
False
```

[[К содержанию](#структура-языка-логический-тип-данных)]

## Операции над объектами логического типа данных

Логический тип данных является подтипом целочисленного типа данных (об этом будет рассказано подробнее в основной части курса). Из этого следует, что объекты логического типа данных поддерживают те же операции, что и целые числа. Рассмотрим основные группы операций.

### Арифметические

Объекты булева типа данных поддерживают арифметические операции. Причем результатом выполнения арифметических операций будет объект целочисленного типа данных или число с плавающей точкой.

*Примеры арифметических операций*:
```Python
# унарный минус
-True                   # == -1
# сложение
True + True             # == 2
# вычитание
True - False            # == 1
# умножение
True * True             # == 1
# честное деление (truediv)
True / True             # == 1.0
# целочисленное деление
True // True            # == 1
# модульное деление
True % True             # == 0
```

### Битовые операции

Объекты булева типа данных поддерживают битовые операции. Результат выполнения - или целое число, или булево значение.

*Примеры битовых операций*:
```Python
# битовое НЕ
~True                   # == -2
# битовое И
True & False            # == False
# битовое ИЛИ
True | False            # == True
# исключающее ИЛИ
True ^ False            # == True
# битовый сдвиг влево
True << True            # == 2
# битовый сдвиг вправо
True >> True            # == 0
```

### Логические операции

Объекты булева типа данных поддерживают логические операции. Результат выполнения - булево значение.

*Примеры логических операций*:
```Python
# оператор равенства
True == False           # == False
# оператор неравенства
True != False           # == True
# оператор больше
True > False            # == True
# оператор больше или равно
True >= True            # == True
# оператор меньше
True < True             # == False
# оператор меньше или равно
True <= True            # == True
```

[[К содержанию](#структура-языка-логический-тип-данных)]

## Операторы and, or, not

С объектами логического типа данных часто используются операторы `not`, `and` и `or`. Рассмотрим эти операторы подробнее.

### not

Оператор `not` является унарным оператором. В качестве операнда оператора `not` используется любой объект Python, реализующий специальный метод `__bool__`. Принцип работы `not` очень простой. Сначала вычисляется логическое представление операнда, путем неявного вызова функции `bool()`. После этого `not` возвращает значение, противоположное логическому представлению переданного объекта.

*Примеры использования `not`*:
```console
>>> not True
False

>>> not 1
False

>>> not []
True
```

Классический сценарий использования `not` - построение отрицательного условия в хедере управляющей конструкции.

### and

Оператор `and` является бинарным оператором. Оператор `and` напоминает логическое И за тем исключение, что тип данных возвращаемых значений не ограничивается булевым типом. Оператор `and` работает следующим образом. Сначала неявно вычисляется логическое представление первого операнда. Если логическое представление первого операнда - `False`, вычисления завершаются, а результат выполнения операции - это первый операнд. Иначе результат выполнения операции - второй операнд.

Обратите внимание, что работа со вторым операндом происходит только в том случае, если логическое представление первого операнда соответствует `True`. Иначе вычисления второго операнда не осуществляются. Это является ярким примером так называемых *ленивых вычислений* в Python.

*Примеры использования оператора `and`*:
```
>>>True and False
False

>>>[] and True
[]
```

### or

Оператор `or` является бинарным оператором. Оператор `or` напоминает логическое ИЛИ. Аналогично оператору `and` тип возвращаемых значений `or` не ограничивается булевым типом. Оператор `or` работает следующим образом. Сначала неявно вычисляется логическое представление первого операнда. Если логическое представление первого операнда - `True`, вычисления завершаются, а результат выполнения операции - это первый операнд. Иначе результат выполнения операции - второй операнд.

Обратите внимание, что работа со вторым операндом происходит только в том случае, если логическое представление первого операнда соответствует `True`. Иначе вычисления второго операнда не осуществляются. Вычисления операции `or` также являются ярким примером ленивых вычислений.

*Примеры использования оператора `or`*:
```
>>>True or False
True

>>>[] or {}
{}
```

[[К содержанию](#структура-языка-логический-тип-данных)]

## Некоторые управляющие конструкции

Как говорилось ранее, объекты булева типа данных используются в условиях управляющих конструкций. Рассмотрим простейшие управляющие конструкции, которые мы можем реализовать с нашим текущим уровнем знаний.

### Ветвление

Ветвление - это сложная инструкция, которая включает в себя положения `if`, `elif` и `else`. В самом общем виде конструкция ветвления выглядит следующим образом:

```Python
if expression1:
    do_something1()

elif expression2:
    do_something2()

elif expression3:
    do_something3()

else:
    do_another_thing()
```

Ветвление работает следующим образом. Если `expression1` расценивается как `True`, то выполняется блок кода, который следует за ним. Иначе Python будет оценивать выражение в первом блоке `elif`, потом во втором, и так далее, пока одно из них не будет расценено как `True`, или пока интерпретатор не дойдет до блока `else`/конца ветвления.

Положения `elif` и `else` являются не обязательными. Т.е. следующие варианты ветвления также являются приемлимыми.

*Пример ветвления без блока `elif`*:
```python
if condition:
    do_something()

else:
    do_another()
```

*Пример ветвления без блока `else`*:
```python
if condition1:
    do_if_case()

elif condition2:
    do_elif_case()
```

Вы вольны использовать любые выражения в положениях `if` и `elif`. Результат выражения, использованного в качестве условия ветвления, неявным образом приводится к логическому типу данных. Отдельно подчеркнем, что результат выполнения выражения необязательно является булевым значением, однако это должен быть объект, поддерживающий приведение к объекту булева типа данных. Именно на основании значения полученного объекта булева типа данных принимается решение о выполнении или невыполнении тела того или иного положения ветвления. Проиллюстрируем это примером:

```python
if [] and True:
    ...
```

В данном примере результат выполнения операции логического И - пустой список (подумайте, почему). Далее интерпретатор Python неявным образов осуществляет вызов `bool([])`, получая объект-синглтон `False`. Поскольку условие ветвления было оценено как ложь, тело данного положения выполнено не будет.

**Замечение 1**: избегайте явного приведения условия к объекту типа `bool`, поскольку это снижает читаемость вашего кода и заставляет интерпретатор выполнять лишние действия.

*Пример, как делать не надо*:
```python
if bool(condition):
    ...
```

*Пример python-way кода*:
```python
if condition:
    ...
```

**Замечание 2**: по причинам аналогичным причинам в замечании 1 избегайте использования явного сравнения переменных с синглтонами `True` и `False`.

*Примеры, как делать не надо*:
```python
# не нужно сравнивать значения явно
# интерпретатор сам вычислит логическое представление
if my_variable == True:
    ...

# такая проверка имеет место
# однако количество ситуаций, в которых она будет полезна, невелико
if my_variable is True:
    ...
```

### Цикл while

Цикл while предназначен для выполнения некоторой последовательности действий до тех пор, пока выражение, стоящее в условии цикла, расценивается как `True`. Логика вычисления условия соответствует логике вычисления условий ветвления.

```Python
while expression:
    do_something()
```

### break

Ключевое слово `break` может быть использовано только в циклах для мгновенного прерывания этих самых циклов. Когда `break` выполняется, цикл завершается. Если имеет место вложенный цикл, содержащий `break`, `break` прерывает только вложенный цикл, в котором он встретился, не затрагивая выполнение внешнего цикла.

### continue

Как и `break`, `continue` может быть использована только в циклах. Инструкция `continue` используется для пропуска части тела цикла и немедленному переходу к следующей итерации. Обычно `continue` используется для уменьшения степени вложенности кода в теле цикла. Например:

*Было до использования `continue`*:
```python
while condition:
    if get_condition():
        do_something()
        do_another_thing()
        update_condition()
```

*Стало после использования `continue`*:
```python
while condition:
    if not get_condition():
        continue

    do_something()
    do_another_thing()
    update_condition()
```

### else в циклах

Помимо очевидного использования `else` в ветвлении, `else` так же может быть использовано вместе с циклами. В контексте циклов слово `else` может сбивать с толку, поскольку по смыслу гораздо сильнее подходило бы слово `then` или `after`, но добавление нового ключевого слова испортило бы обратную совместимость, чего создатель языка Python Гвидо Ван Россум старательно избегает. Собственно, блок `else`, размещенный после цикла, будет выполняться только в том случае, когда цикл был завершен "естественным путем": без прерывания в теле цикла с помощью инструкции `break`.

*Пример*:
```python
while condition:
    if not get_break_condition():
        break

    do_something()
    do_another_thing()
    update_condition()

else:
    finish_while_loop()
```

В данном примере блок `else` будет выполнен только в том случае, если не была выполнена инструкция `break`.

[[К содержанию](#структура-языка-логический-тип-данных)]
