# Последовательности: списки и кортежи

**Содержание:**
- [Последовательности](#последовательности);
- [Операции над последовательностями](#операции-над-последовательностями);
- [Замечания о конкатенации](#замечание-о-конкатенации-и-повторении);
- [Кортежи](#кортежи);
- [Неизменяемость кортежей](#неизменяемость-кортежей);
- [Операции над кортежами](#операции-над-кортежами);
- [Списки](#списки);
- [Операции над списками](#операции-над-списками);
- [Цикл for](#цикл-for);
- [range](#range);
- [map](#map);

## Последовательности

Помимо числовых типов данных, которые были рассмотрены на предыдущих занятиях, встроенные типы данных Python включают в себя коллекции, т.е. объекты, которые могут быть использованы для хранения других объектов по определенным правилам. Существует несколько видов коллекций. Одним из таких видов являются **последовательности**. В Python под последовательностями понимается упорядоченная коллекция, которая может быть проиндексирована целыми числами. Последовательности в Python должны поддерживать вызов встроенной функции `len()`, а также поддерживать индексирование целыми числами через квадратные скобки `[]`.

Встроенные типы данных, которые являются последовательностями, включают в себя списки, кортежи и строки. В данном занятии речь пойдет о кортежах и списках.

[[К содержанию](#последовательности-списки-и-кортежи)]

## Операции над последовательностями

Несмотря на то, что объекты различных типов данных, относящиеся к последовательностям, не обязаны поддерживать одинаковый набор допустимых операций, существует множество операций, поддерживаемых каждой последовательностью. В данном разделе рассмотрим операции, которые должны поддерживаться последовательностями.

### Конкатенация и повторение

Последовательности, относящиеся к одному и тому же типу данных, поддерживают операции конкатенации. Под конкатенацией подразумевается объединение содержимого последовательностей путем дописывания элементов одной последовательности в конец другой. Операция конкатенации осуществляется с помощью оператора `+`. Результат конкатенации - новая последовательность, содержащая в себе элементы операндов.

*Примеры конкатенации*:
```python
# конкатенация списков
>>> [1, 2, 3] + [4, 5]
[1, 2, 3, 4, 5]

# конкатенация кортежей
>>> (1, 2, 3) + (4, 5)
(1, 2, 3, 4, 5)

# конкатенация в составном присваивании
>>> array = [1, 2, 3]
>>> array += [4, 5]     # array == [1, 2, 3, 4, 5]
```

Помимо конкатенации последовательности поддерживают операцию повторения. Повторение очень похоже на конкатенацию за тем исключением, что повторение позволяет несколько раз конкатенировать исходную последовательность саму с собой. Повторение осуществляется с помощью бинарного оператора `*`. В качестве одного из операндов оператора `*` в контексте повторения последовательностей должна выступать последовательность, которую требуется повторить. В качестве второго операнда - целое положительное число. Порядок операндов несущественен.

*Примеры повторений последовательностей:*
```python
# повторение списка
>>> [1, 2] * 2
[1, 2, 1, 2]

# повторение кортежа
>>> 2 * (3, 4, 5)
(3, 4, 5, 3, 4, 5)

# повторение в составном присваивании
>>> tuple_ = (1, 2)
>>> tuple_ *= 2         # tuple_ == (1, 2, 1, 2)
```

При использовании целых отрицательных чисел или `0` в качестве второго операнда оператора повторения последовательностей, результатом будет пустая последовательность. При использовании чисел с плавающей точкой в качестве второго операнда повторения интерпретатор возбудит исключение `TypeError`.

*Пример некорректных повторений:*
```python
# повторение 0 раз
>>> (1, 2) * 0
()

# повторение отрицательное число раз
>>> [3, 4, 5] * -1
[]

# повторение с некорректным операндом
>>> (1, 2) * 0.5
TypeError: ...
```

### Проверка наличия элементов

Все последовательности поддерживают проверку наличия объектов. Проверка наличия того или иного объект в последовательности осуществляется с помощью бинарного оператора `in`. В качестве левого аргумента оператора `in` выступает объект, чье наличие в коллекции мы хотим проверить. В качестве правого аргумента - последовательность, для которой осуществляется проверка. Результатом выполнения оператора `in` является булево значение: истина, если последовательность содержит данные объект, ложь - иначе.

*Примеры проверки вхождения элемента*:
```python
>>> 3 in [1, 2, 3]
True

>>> 3 in (4, 5, 6)
False
```

Существует две формы отрицания оператора `in` для проверок того, что данного объект нет в данной последовательности:

```python
# менее предпочтительный вариант отрицания
>>> not (3 in [1, 2, 3])
False

# более предпочтительный вариант отрицания
>>> 3 not in [1, 2, 3]
False
```

Из примера видно, что оба варианта являются эквивалентными. Однако второй вариант является более предпочтительным в силу большей читабельности и приближенности к естественным языкам.

### Индексация

Последовательности поддерживают чтение элементов с использованием целочисленного индекса и обращения через квадратные скобки `[]`. Индексация начинается с нуля. Т.е. первому элементу последовательности соответствует целочисленный индекс `0`.

*Примеры индексации*:
```python
# индексация списков
>>> array = [1, 2, 3]
>>> array[0]
1

# индексация кортежей
>>> tuple_ = (4, 5, 6)
>>> tuple_[2]
6
```

Помимо положительных значений индекс может принимать и отрицательные целочисленные значения в диапазоне [`-n`; `-1`], где `n` - количество элементов в коллекции. Чтобы лучше понять смысл отрицательных индексов, вы можете воспринимать отрицательный индекс `-i` как индекс `n - i`, т.е. отрицательному индексу `-1` соответствует элемент последовательности `n - 1` - последний элемент. Индексу `-n` - элемент `n - n`, т.е. первый элемент последовательности.

*Примеры использования отрицательных индексов*:
```python
# индексация списков
>>> array = [1, 2, 3]
>>> array[-3]
1

# индексация кортежей
>>> tuple_ = (4, 5, 6)
>>> tuple_[-1]
6
```

Таким образом допустимый диапазон индексов последовательностей: [`-n`; `n - 1`], где `n` - количество элементов в последовательности. Если индекс не является целым числом, интерпретатор возбуждает исключение `TypeError`. Если целочисленный индекс выходит за диапазон допустимых индексов, интерпретатор возбуждает исключение `IndexError`.

*Примеры исключений*:
```python
>>> array = [1, 2, 3]
>>> array[0.5]
TypeError: ...

>>> tuple_ = (4, 5, 6)
>>> tuple_[42]
IndexError: ...
```

### Срезка

Помимо целочисленный индексации, встроенные в язык последовательности поддерживают индексацию с помощью **срезов**. Срезы в Python - это специальные объект типа *срез* (англ. *slice*), которые используются для получения подпоследовательности из заданной последовательности (подпоследовательность используется не в строго математическом смысле). Объект среза может быть создан с помощью вызова `slice(start, stop, step)`, однако в контексте индексации через квадратные скобки `[]` создание объекта среза имеет упрощенный синтаксис.

*Примеры создания срезов:*
```python
# с помощью вызова slice()
my_slice = slice(1, 10, 2)

# в контексте индексации с мгновенным использованием
array[1:10:2]
```

При создании среза первое число соответствует позиции для начала среза, второй - конец среза, причем позиция `start` включается в среза, а позиция `stop` - нет. Третье число соответствует шагу среза. В примерах выше шаг среза равен двум, т.е. в результирующей подпоследовательности будет присутствовать каждый второй элемент из полуинтервала [`1`; `10`). При создании среза должен быть передан как минимум один аргумент. Остальные два аргумента могут быть опущены.

*Примеры использования срезов*:
```python
arr = [1, 2, 3, 4, 5]

# все числа с позиций [1, 3)
arr[1:3]        # == [2, 3]
# все числа с позиций [0, 3]
arr[:3]         # == [1, 2, 3)
# все числа с позиций [1, 4]
arr[1:]         # == [2, 3, 4, 5]
# все числа с четными индексами
arr[::2]        # == [1, 3, 5]
# все числа в обратном порядке
arr[::-1]       # == [5, 4, 3, 2, 1]
# числа из диапазона [1, 3] в обратном порядке
arr[-2:-5:-1]   # == [4, 3, 2]
```

### Проверка количества элементов

Последовательности поддерживают проверку количества элементов с помощью функции `len()`. Функция `len()` принимает на вход последовательности и возвращает целое неотрицательное число - число элементов в последовательности.

*Примеры использования `len()`:*
```python
# проверка количества элементов в списке
>>> len([1, 2, 3])
3

# проверка количества элементов в кортеже
>>> len(())
0

# проверка количества элементов в строке
>>> len("abcdef")
6
```

[[К содержанию](#последовательности-списки-и-кортежи)]

## Замечание о конкатенации и повторении

При выполнении операций конкатенации и повторения создается новая последовательность с копиями элементов исходных последовательностей. Однако копии эти являются *наивными* (англ. *shallow*) копиями элементов. Это значит, что новых объектов в памяти не создается, создаются лишь новые ссылки на уже существующие объекты, которые и помещаются в результирующую последовательность. Отсюда следует, что если элементы исходных последовательностей являлись объектами изменяемых типов данных, то мы получаем возможность влиять на содержимое исходных последовательностей путем изменения значений элементов результата и наоборот. Именно поэтому стоит быть особенно осторожными при конкатенации и повторении последовательностей объектов изменяемых типов данных. Проиллюстрируем сказанное выше примерами:

```python
# повторение с изменяемыми элементами
>>> seq = [[3]] * 3
>>> seq
[[3], [3], [3]]
>>> seq[0][0] = 1
>>> seq
[[1], [1], [1]]

# конкатенация с изменяемыми элементами
>>> seq1 = [[1]]
>>> seq2 = [[2]]
>>> seq3 = seq1 + seq2
>>> seq3
[[1], [2]]
>>> seq3[0][0] = 42
>>> seq3
[[42], [2]]
>>> seq1
[[42]]
```

[[К содержанию](#последовательности-списки-и-кортежи)]

## Кортежи

Кортежем (англ. *tuple*) в Python называется неизменяемая последовательность элементов. Кортеж может содержать объект разных типов данных. Количество элементов, которое может содержать кортеж, ограничивается исключительно объемом памяти компьютера.

Кортеж может быть создан с помощью вызова `tuple()`. В качестве аргумента может быть использован любой итерируемый объект. В данной части курса, можно думать, что объект является итерируемым если мы можем перебрать его значения в цикле `for`, о чем будет сказано ниже. Сам кортеж, к слову, также является итерируемым. Рассмотрим примеры создания кортежа из других последовательностей:

```python
# создание кортежа из списка
>>> tuple([1, 2, 3])
(1, 2, 3)

# создание кортежа из другого кортежа
>>> tuple((3, 4, 5))
(3, 4, 5)

# создание кортежа из строки
>>> tuple("hello")
('h', 'e', 'l', 'l', 'o')

# создание пустого кортежа
>>> tuple()
()
```

Также вы можете создавать новые кортежи, используя литералы кортежей. Рассмотрим валидные литералы для создания кортежа:

```python
(1, 2, 3)       # == (1, 2, 3)
1, 2, 3         # == (1, 2, 3)
(3.14, )        # == (3.14, )
3.14,           # == (3.14, )
()              # пустой кортеж
```

**Важно**: чтобы с помощью литерала создать кортеж, состоящий из одного элемента, необходимо использовать следующие литералы: `elem,` или `(elem, )`. Кортеж с одним элементом будет создан только из таких литералов. Литерал `(elem)` будет интерпретирован, как `elem`. Такая запись создавать кортеж не будет.  

[[К содержанию](#последовательности-списки-и-кортежи)]

## Неизменяемость кортежей

Как было сказано выше, кортежи - неизменяемые типы данных. Это значит, что вы не можете изменять элементы кортежа, т.е. вы не можете заменить один объект, являющийся элементом кортежа, на другой. После создания вы не сможете изменить количество элементов, добавив или удалив элементы. Однако, если кортеж хранит объекты изменяемого типа данных, вы можете изменить значения этого объекта.

*Пример изменения значения элемента кортежа*:
```python
>>> tuple_ = (1, 2, [])
>>> tuple_
(1, 2, [])

>>> tuple_[-1].append(5)
>>> tuple_
(1, 2, [5])
```

На первый взгляд может показаться, что это противоречит неизменяемости кортежа. На самом деле неизменяемость объекта говорит нам о неизменяемости контента содержимого этого объекта. В самом кортеже лежат ссылки на объекты Python. При изменении значения объекта изменяемого типа данных, сама ссылка на этот объект изменений не претерпевает, а следовательно, с точки зрения интерпретатора, значение кортежа никаких изменений не претерпело. Никакого парадокса тут нет.

В противовес этому поведению, приведем примеры явных попыток изменить значение кортежа, которые закономерно приводят к ошибкам:

```python
>>> tuple_ = (1, 2, 3, 4, 5)

# попытка привязать ссылку к другому объекту
>>> tuple_[1] = 42
TypeError: ...

# попытка удалить ссылку
>>> del tuple_[1]
TypeError: ...
```

**Замечание**: несмотря на то, что у вас есть возможность изменять значения элементов кортежа изменяемого типа данных, старайтесь избегать такого поведения. Это может затруднить понимание вашего кода и ваших намерений другими разработчиками.

[[К содержанию](#последовательности-списки-и-кортежи)]

## Операции над кортежами

Поскольку кортежи являются последовательностями, кортежи поддерживают все операции последовательностей, перечисленные выше.

### Логические операции

Также кортежи поддерживают все логические операции, в частности операции сравнения. Логический операции вычисляются поэлементно. В случае операций сравнения результат операции будет соответствовать результату сравнения первой паре элементов, значения которых оказались неравными.

*Примеры логических операций*:
```python
>>> (1, 2, 3) == (4, 5, 6)
False

>>> (1, 2, 3) != (4, 5, 6)
True

>>> (1, 2, 3) < (4, 5)
True

>>> (1, 2, 3) <= (4, 5)
True

>>> (1, 2, 3) > (4, 5)
False

>>> (1, 2, 3) >= (4, 5)
False
```

### Методы кортежей

Помимо операций последовательностей, кортежи обладают двумя методами: `index()` и `count()`. Методы объекта - это функции, связанные с конкретным объектом, и использующие его состояние для реализации каких-либо вычислений. Для того, чтобы воспользоваться каким-либо методом объекта, необходимо осуществить следующий вызов: `object_name.method_name()`. Вызов метода похож на вызов функции за тем исключением, что перед идентификатором метода должен находится идентификатор объекта. Идентификатор объекта и идентификатор метода разделяются точкой.

Метод кортежа `index()` принимает на вход объект Python и позволяет определить индекс первого вхождения этого объекта в последовательности. Если данного объекта в последовательности нет, интерпретатор возбудит `ValueError`.

*Примеры использования `index()`*:
```python
>>> tuple_ = (1, 2, 3, 4, 5)

# элемент со значением 3 имеет индекс 2
>>> tuple_.index(3)
2

# в данном кортеже нет элемента "a"
>>> tuple_.index("a")
ValueError: ...
```

Метод кортежа `count()` принимает на вход объект Python и возвращает целое число - количество элементов кортежа со значением, равным значению переданного объекта.

*Примеры использования `count()`*:
```python
>>> tuple_ = (1, 2, 3, 4, 3, 3)

>>> tuple_.count(3)
3

>>> tuple_.count("a")
0
```

[[К содержанию](#последовательности-списки-и-кортежи)]

## Списки

Списками (англ. *list*) в Python называются изменяемые последовательности элементов. Элементы списка - это объекты различных типов данных. Списки очень похожи на кортежи, за тем исключением, что списки являются изменяемыми и обладают дополнительными *модифицирующими методами*.

Список может быть создан с помощью специального вызова `list()`. На вход объекту `list()` подается произвольный итерируемый объект. Вызов без аргументов приведет к созданию пустого списка.

*Примеры создания списков с помощью `list()`*:
```python
# создание списка из списка
>>> list([1, 2, 3])
[1, 2, 3]

# создание списка из кортежа
>>> list((3, 4, 5))
[3, 4, 5]

# создание списка из строки
>>> list("hello")
['h', 'e', 'l', 'l', 'o']

# создание пустого списка
>>> list()
[]
```

Также вы можете создавать новые списки, используя списковые литералы. Рассмотрим валидные литералы для создания списка:

```python
[42, 3.14, 'string']
[100]
[]
```

[[К содержанию](#последовательности-списки-и-кортежи)]


## Операции над списками

Списки поддерживают все операции свойственные последовательностям. Также, по аналогии с кортежами, списки поддерживают логические операции и вызов методов: `index()` и `count()`.

Поскольку списки - это изменяемые объекты, мы можем не только читать значение их элементов с помощью обращений через квадратные скобки `[]`, но и перепривязывать элементы списка к новым объектам, добавлять новые элементы и удалять старые.

*Примеры изменения содержимого списка:*
```python
nums = [1, 2, 3, 4, 5]
nums[1] = 42                # [1, 42, 3, 4, 5]
nums[2:4] = [5, 6, 7, 8]    # [1, 42, 5, 6, 7, 8, 5]
nums[2:2] = [3, 3, 3]       # [1, 42, 3, 3, 3, 5, 6, 7, 8, 5]
nums[2:7] = []              # [1, 42, 7, 8, 5]
nums[:] = [1]               # [1]
del nums[0]                 # []
```

Также списки обладают методом `copy()` и  рядом *модифицирующих*  методов. Метод `copy()` используется для создания наивной копии списка. Все модифицирующие методы списков не создают нового объекта и изменяют значения текущего объекта на месте. Все модифицирующие методы возвращают `None`. В таблице ниже приведена информация о каждом модифицирующем методе списка.

|Сигнатура|Описание|
|--|--|
|`append(x)`|добавляет объект `x` в конец списка|
|`clear()`| удаляет содержимое списка|
|`extend(i)`|добавляет все элементы из итерируемого объекта `i` в конец списка|
|`insert(i, x)`|вставляет элемент `x` перед элементом с индексом `i`; если индекс `i` выходит из диапазона допустимых индексов, то элемент `x` будет вставлен в один из концов списка|
|`pop(i=-1)`|возвращает элемент под индексом `i` и удаляет его из списка; удаляет последний элемент, если значение `i` опущено; если список пуст или `i` - недействительный индекс, вызывает исключение|
|`remove(x)`|удаляет из списка первое вхождение элемента `x`|
|`reverse()`|изменяет порядок следования элементов в списке на обратный|
|`sort(key=None, reverse=False)`|сортирует список на месте; по умолчанию сортировка осуществляется в порядке возрастания|

[[К содержанию](#последовательности-списки-и-кортежи)]

## Цикл for

Итак, наконец мы подобрались к циклу `for`. Цикл `for` - это составная инструкция, которая позволяет выполнить блок кода фиксированное число раз. Очередное выполнение блока кода называется итерацией. Число итераций связано с количеством элементов, которое может породить итерируемый объект, используемый в данном цикле. Синтаксически цикл `for` записывается следующим образом:

```python
for i in iterable:
    ...
```

Подробнее разберем из чего состоит цикл `for`:
- цикл `for` начинается с ключевого слова `for`;
- далее за ключевым словом `for` следует идентификатор переменной цикла, с которым будут связываться значения, извлекаемые из итерируемого объекта на каждой итерации цикла;
- далее следует ключевое слово `in` (не путать с бинарным оператором) и сам итерируемый объект, из которого будут извлекаться некоторые значения;
- затем после двоеточия `:` идет тело цикла.

В общих чертах цикл `for` работает следующим образом:
- на каждой итерации с помощью итерируемого объекта получается очередной объект, который может быть элементом этого итерируемого объекта или может быть создан с помощью данного объекта;
- извлеченный объект связывается с переменной цикла `i`, название переменной может быть любым;
- затем выполняется тело цикла;
- если в начале очередной итерации не удалось получить новый объект с помощью итерируемого объекта, выполнение цикла `for` прекращается.

Проиллюстрируем выполнение цикла `for` примером:

```python
nums = [1, 2, 3, 4, 5]

for num in nums:
    print(num)
```

В данном примере мы просто переберем все элементы списка и распечатаем их.

Цикл `for` поддерживает использование инструкций `break` и `continue` в своем теле. Также для цикла `for` вы можете использовать блок `else`, который будет работать точно так же, как и блок `else` в цикле `while`.

Переменная цикла не является локальной для данного цикла, в отличие от переменных цикла в других языках программирования. Поэтому вы спокойно можете использовать переменную цикла вне данного цикла после его выполнения.

*Пример использования переменной цикла*:
```python
nums = [1, 2, 3, 4, 5]

for num in nums:
    print(num)

print(num)
# 4 - последний элемент
```

[[К содержанию](#последовательности-списки-и-кортежи)]

## range

В качестве итерируемого объекта часто используется объект `range`, который позволяет генерировать целые числа в заданном диапазоне с заданным шагом.

*Пример использования range*:
```python
for i in range(5):
    print(i)
```

По умолчанию `range` генерирует числа от `0` до `n - 1`, где `n` - переданная правая граница диапазона. В данном примере с помощью `range` будут сгенерировано 5 целых чисел от 0 до 4. Вы также можете указать начальное значение для генерации и шаг:

```python
for i in range(1, 5, 2):
    print(i)
```

В данном примере будут сгенерированы и распечатаны все нечетные числа в диапазоне от `1` до `4` включительно.

[[К содержанию](#последовательности-списки-и-кортежи)]

## map

В Python присутствует встроенный объект `map`, который предназначен для применения одной и той же функции ко всем элементам итерируемого объекта. Функция `map` может быть очень полезна, если вам необходимо применить одну и ту же операцию к элементам определенной последовательности. В этом случае вызов `map` может заменить цикл `for`.

Входом объекта `map` является функция, которую нужно применить к элементам итерируемого объекта, а также сам итерируемый объект. Проиллюстрируем это примером:

```python
nums_string = input()
nums = list(map(int, nums_string.split()))
```

В данном примере мы считали последовательность чисел, разделенную пробелами, и получили на основе этой последовательности список целых чисел.

`map` возвращает специальный объект генератор, о которых в данной части курса мы говорить не будем. Генераторы являются итерируемыми объектами, поэтому они могут быть использованы для преобразования в список или кортеж.

[[К содержанию](#последовательности-списки-и-кортежи)]
