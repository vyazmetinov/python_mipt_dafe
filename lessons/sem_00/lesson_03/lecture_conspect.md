# Числа и функции

**Содержание:**

- [Числовые типы данных](#числовые-типы-данных);
- [Целые числа](#целые-числа);
- [Числа с плавающей точкой](#числа-и-функции);
- [Операции над числами](#операции-над-числами);
- [Функции](#пользовательские-функции);
- [Пользовательские функции](#пользовательские-функции);
- [Параметры функции](#параметры-функции);
- [Параметры по умолчанию](#параметры-по-умолчанию);
- [Аннотации типов](#аннотации-типов);
- [return](#return);
- [min и max](#min-и-max);

## Числовые типы данных

В Python существует три числовых типа данных: *целые числа*, *числа с плавающей точкой* и *комплексные числа*. В рамках данной части курса комплексные числа обсуждаться не будут. Объекты числового типа данных могут быть созданы с помощью числовых литералов или как результат выполнения какого-либо выражения (функции или оператора).

Числовые типы данных являются неизменяемыми типами данных. Отсюда следует, что операции почти со всеми объектами числовых типов данных приводят к созданию новых объектов числовых типов данных. Мы говорим почти, поскольку интерпретатор Python заранее создает и размещает в памяти объекты с некоторыми "часто используемыми" целочисленными значениями. Так, например, на машине, на которой был написан данный конспект, в памяти заранее размещались целочисленные объекты со значениями от -5 до 256. Таким образом, если результатом выполнения какой-либо операции будет являться число из указанного диапазона, создание нового объекта происходить не будет. Все, что сделает интерпретатор - привяжет идентификатор к существующему объекту.

*Пример вычислений "часто используемых" значений*:
```console
>>> num1, num2 = 5, 10
>>> num3 = num2 - num1
>>> num1 is num3
True
```

*Пример вычислений "нечасто используемых" значений*:
```console
>>> num1, num2 = 500, 1000
>>> num3 = num2 - num1
>>> num1 is num3
False
```

[[К содержанию](#числа-и-функции)]

## Целые числа

Целые числа в Python являются компьютерным представлением множества целых чисел, т.е. множества натуральных чисел, расширенных нулем и отрицательными числами. В отличие от более низкоуровневых языков программирования, типа C++, в Python макимальное и минимальное значения объектов целочисленного типа данных не имеют четких ограничений. Максимальное и минимальное значение объектов целочисленного типа данных ограничено исключительно количеством свободного места в памяти. С одной стороны данный подход является удобным, поскольку разработчики получают возможность меньше беспокоиться о переполнении, особенно при работе с большими числами. Однако из-за особенностей хранения целочисленных значений в Python, данный подход накладывает определенные ограничения на производительность.

Для создания объектов целочисленного типа данных используется встроенный объект `int()`. Объекты целочисленного типа данных могут быть созданы из любого объект, у которого определен специальный метод `__int__`. К встроенным типам данных, которые поддерживают преобразование в целочисленный тип данных, относятся: логический тип, числа с плавающей точкой, строки и байты. Значение целочисленного объекта, созданного из числа с плавающей точкой, получается путем отбрасывания дробной части переданного числа.

*Примеры преобразования объектов в целые числа*:
```console
>>> int(True)
1

>>> int(3.14)
3

>>> int("123")
123

>>> int(b"123")
123
```

Также при создании объекта целочисленного типа с помощью вызова `int()` вы можете указать основание системы счисления, в которой находится переданная в `int()` запись числа. Для указания основания системы счисления используется параметр `base`. По умолчанию `int()` ожидает получить десятичную запись числа.

*Примеры использования `base`*:
```console
>>> int("101", base=2)
5

>>> int("123", base=8)
83

>>> int("ABC", base=16)
2748
```

**Важно**: при использовании параметра `base` `int()` ожидает получить запись числа в форме строки.

Помимо использования `int()` объект целочисленного типа данных может быть создан с помощью целочисленного литерала. В Python целочисленные литералы могут двоичную, восьмеричную, десятичную и шестнадцатеричную форму записи. Проиллюстрируем каждую форму записи:

```python
0b1000101       # двоичная форма записи
0o105           # восьмеричная форма записи
69              # десятичная форма записи
0xa9            # шестнадцатеричная форма записи
```

**Важно**: ни один целочисленный литерал, записанный в десятичной форме записи, кроме нуля, не может начинаться с нуля. В противном случае такая запись приведет к ошибке `SyntaxError`.

Также целочисленные литералы могут содержать ведущий унарный `+` или `-`. Запись с унарным `+` соответствует положительным числам и не имеет особо смысла, посокльку запись `5` и `+5` соответствуют одному и тому же значению. Запись с унарным `-` соответствует отрицательным числам.

Вы можете использовать нижнее подчеркивание `_` в целочисленных литералах для увеличения читабельности значения. Так, например, нижнее подчеркивание `_` может быть использовано для разделение триплетов цифр:

```python
1_000_000_000
0xF1c5_910D_FF0A
```

[[К содержанию](#числа-и-функции)]

## Числа с плавающей точкой

Числа с плавающей точкой в Python являются компьютерным представлением действительных чисел. Числа с плавающей точкой в Python похожи на числа с плавающей точкой в C. В отличие от целых чисел, числа с плавающей точкой занимают конкретное число байт и имеет строго определенные максимальное и минимальное значение. Максимальные и минимальные значения для чисел с плавающей точкой зависят от конкретной платформы.

Объект типа числа с плавающей точкой может быть создан с помощью вызова `float()`. Конвертацию в числа с плавающей точкой поддерживают объекты любого типа данных, для которых определен специальный метод `__float__`. Встроенные типы данных, поддерживающие преобразование: логический тип данных, целые числа, строки.

*Примеры преобразования объектов в числа с плавающей точкой*:
```console
>>> float(True)
1.0

>>> float(123)
123.0

>>> float("56.7")
56.7
```

При создании объекта типа число с плавающей точкой из строки, строка должна являться валидной записью числа с плавающей точкой, или одним из специальных значений: `+inf` - плюс бесконечность, `-inf` - минус бесконечность и `nan` - Not A Number, специальное сигнальное значение.

*Примеры использования специальных значений*:
```console
>>> float("+inf")
inf

>>> float("-inf")
-inf

>>> float("nan")
nan
```

Также, по аналогии с целыми числами, объект типа число с плавающей точкой может быть создан с помощью действительного литерала. Литералы числе с плавающей точкой могут содержать цифры от `0` до `9`, `.` для разделения целой и дробной части, `e` для обозначения степени, `-` и `+`, относящиеся к префиксу или к степени. Как и целочисленные литералы, литерал числа с плавающей точкой может начинаться со знаков `+`, `-`. Также литерал может начинаться любого количества ведущих нулей или со знака `.`.

*Примеры валидных литералов чисел с плавающей точкой*:

```python
3.14            # 3.14
-3.14           # -3.14
00003.14        # 3.14
.314            # 0.314
3.14e0          # 3.14
314e-2          # 3.14
```

По аналогии с целочисленными литералами, литералы чисел с плавающей точкой поддерживают использование нижних подчеркиваний `_` для повышения читабельности.

[[К содержанию](#числа-и-функции)]

## Операции над числами

### Арифметические операции

Очевидно, что числовые типы данных поддерживают арифметические операции. Арифметические операции поддерживаются для объектов разных числовых типов. Т.е. вы можете осуществлять арифметические операции между целыми числами и числами с плавающей точкой одновременно. В этом случае объект целочисленного типа данных будет неявным образом преобразован к объекту тип число с плавающей точкой, а результат будет объектом типа число с плавающей точкой.

*Поддерживаемые арифметические операции*:
```python
-5          # унарный минус
+3.14       # унарный плюс
3.14 + 5    # сложение
5 - 3.14    # вычитание
3.14 * 5    # умножение
5 / 3.14    # честное деление (truediv)
5 // 3.14   # целая часть от деления
5 % 3.14    # остаток от деления
3.14 ** 5   # возведение в степень
```

Помимо операций, записанных с помощью операторной записи, числовые объекты поддерживают вызов встроенных арифметических функций: `pow()`, `divmod()` и `abs()`. Функция `pow()` соответствует оператору `**`, но при этом является более гибкой, поскольку позволяет вычислять возведение в степень по модулю:

```python
# обычное возведение в степень
pow(2, 4)       # == 16

# возведение в степень по модулю 10
pow(2, 4, 10)   # == 6
```

Функция `divmod()` позволяет одним вызовом получить пару: целая часть от деления и остаток от деления. `abs()` - абсолютное значение, или модуль, числа.

```python
# вычисления целой части и остатка
divmod(5, 3)    # == (1, 2)

# вычисление модуля
abs(-3.14)      # == 3.14
```

### Логические операции

Числовые типы данных поддерживают все логические операции. Вы также можете сравнивать числовые объекты разных типов данных между собой с помощью логических операторов. Результат выполнения логических операций - объект булева типа данных.

*Поддерживаемые логические операции*:
```python
5 == 3.14       # равенство
5 != 3.14       # неравенство
5 > 3.14        # больше
5 >= 3.14       # больше или равно
5 < 3.14        # меньше
5 <= 3.14       # меньше или равно
```

**Важно**: избегайте прямых сравнений типа `==` и `!=` с использованием чисел с плавающей точкой. Из-за особенностей хранения и квантования чисел, операторы `==` и `!=` могут выдавать не тот результат, что вы ожидаете увидеть. Как следствие ваша программа будет работать неверно. Вместо прямого сравнения чисел с плавающей точкой, вы можете использовать специализированные функции из сторонних библиотек или сравнить значения с требуемой точностью следующим образом:

```python
eps = 1e-6
num1 = 3.14
num2 = 2.72

if abs(num1 - num2) < eps:
    print("equals")

else:
    print("not equals")
```

В данном примере мы определили точность сравнения, как 6 знаков после запятой. Если абсолютная разница чисел не превышает `1e-6`, т.е. если числа равны до шестого знака после запятой включительно, то мы считаем такие числа равными.

### Битовые операции

Объекты целочисленного типа данных поддерживают битовые операции. Битовые операции - это операции, которые выполняются побитово, т.е. между каждым битом операндов.

*Поддерживаемые битовые операции*:
```python
# изменение бита 1 на бит 0 и наоборот
~5              # битовое НЕ
# операция И между соответствующими битами операндов
5 & 4           # битовое И
# операция ИЛИ между соответствующими битами операндов
5 | 4           # битовое ИЛИ
# операция исключающего ИЛИ между соответствующими битами операндов
5 ^ 4           # ислючающее ИЛИ
# смещение битов 5 на 2 позиции влево
5 << 2          # смещение битов влево
# смещение битов 5 на 2 позиции вправо
5 >> 2          # смещение битов вправо
```

[[К содержанию](#числа-и-функции)]

## Функции

Функциями в Python называется именованный набор инструкций, который выполняется по определенному запросу - функциональному вызову. В Python существует большое количество встроенных функций, с некоторыми из них мы уже знакомы. Например, на прошлом занятии мы поработали со встроенными функциями `print()` и `input()`, а в рамках этого занятия познакомились с функциями `abs()`, `pow()` и `divmod()`.

Почти в любой Python программе используются и определяются функции в том или ином виде. Такой подход к организации исходного кода имеет ряд преимуществ:
- Увеличение степени читаемости вашего кода. Хорошо продуманная функция поможет вам лучше структурировать исходный код и лучше донести вашу задумку до других разработчиков.
- Повторное использование кода. Поскольку фунции поддерживают неоднократное выполнение функциональных вызовов, вы можете с легкостью использовать одну и ту же функцию несколько раз в различных местах программы, избегая дублирования кода.
- Производительность. Код, оформленный в виде функции, может выполняться быстрее кода, оставленного на уровне модуля.

[[К содержанию](#числа-и-функции)]

## Пользовательские функции

В Python, помимо использования встроенных функций, вы также имеете возможность определять и использовать собственные функции, которые удовлетворяют актуальным потребностям. Пользовательскими функциями называются функции, который были созданы непосредственно вами. Самый распространенный способ создания пользовательской функции - это выполнение инструкции по созданию функции с помощью ключевого слова `def`. `def` - это составная инструкция, состоящая из одного положения. В общем случае `def`-инструкция выглядит следующим образом:

```python
def function_identifier(param1, param2):
    statement1
    statement2
    ...
```

Рассмотрим это утверждение по частям:
- Ключевое слово `def`, как говорилось выше, используется для того, чтобы дать интерпретатору понять, что далее идет определение пользовательской функции.
- Следом за ключевым словом `def` идет идентификатор функции `function_identifier`. Идентификатор функции - это имя, которое необходимо использовать для осуществления манипуляций с функцией. Имя функции пишется в `snake_case`.  
    **Замечание**: старайтесь давать функциям понятные имена, отражающие назначение данной функции. Имена хороших функций обычно начинаются с глаголов. Пример хорошего имя функции: `read_data_from_bd`. Пример плохого имени функции: `func`.
- За идентификатором функции в круглых скобочках перечислены имена параметров функции. Имена параметров должны быть уникальными. Имена параметров разделяются запятыми. Параметры функции определяют какое количество аргументов может быть передано в функцию во время ее вызова для выполнения описанных функцией операций. Если последовательность параметров пуста, функция не поддерживает передачу каких-либо данных в момент функционального вызова.
- За блоком параметров следует двоеточие `:`.
- Далее, с большим уровнем отступа, идет тело функции. Тело функции - это набор инструкций, которые будут выполняться во время функционального вызова.

После выполнения `def`-инструкции, в программе будет определена новая функция, или переопределена, если функция с именем `function_identifier` уже существовала. Функция не выполняется сразу после определения. Для выполнения функции, необходимо осуществить функциональный вызов, который выглядит так:

```python
function_identifier(arg1, arg2)
```

Т.е. синтаксически функциональный вызов выглядит, как идентефикатор функции, справа от которого в круглых скобках переданы аргументы. Если функция имела пустое множество параметров или все параметры были необязательными, вызов функции будет выглядеть так:

```python
function_identifier()
```

[[К содержанию](#числа-и-функции)]

## Параметры функции

Параметры функции определяют последовательность имен, с которыми будут связывать передаваемые во время функционального вызова данные. Параметры со значением по умолчанию также определяют значение параметра, которое будет использоваться в случае, если соответствующий аргумент не будет передан во время функционального вызова.

В момент функционального вызова переданные данные связываются с именами параметров в зависимотси от порядка, в котором были переданы данные. Вы также можете связать конкретные данные с конкретным параметром явно, с помощью вызова вида `param=arg`. В момент связки данных с именами создаются переменные, которые могут быть использованы только в теле функции. Переменные, которые могут быть использованы только в теле данной функции, называются **локальными переменными** для данной функции. Локальные переменные образуют пространство имен функции. Пространство имен функции создается заново при каждом вызове функции, и уничтожается при выходе из функции.

Во время связки имен параметров с переданными данными нового объекта не создается, создается лишь новая ссылка на существующий объект, которая имеет имя параметра функции. Эта ссылка существует только во время выполнения функции и удаляется после выхода из функции. Рассмотрим это на примере:

```python
def print_object_id(obj: object) -> None:
    obj_id = id(obj)
    print(f"{obj_id = }")

num = 500
print(id(num))          # 1885641257584
print_object_id(num)    # 1885641257584
```
В данном примере мы создали простую функцию, которая принимает на вход Python-объект и печатает его `id`. Затем мы создали переменную `num`. В момент ее создания был создан объект целочисленного типа со значением `500`, и переменная `num` была связана с этим объектом. В следующей строке мы распечатали `id` созданного выше объекта. После чего мы вызвали функцию `print_object_id`, передав в качестве аргумента наш объект `num`. Вывод функции содержит тот же `id`, что мы видели в предыдущей строке. Это значит, что в момент вызова функции была создана локальная переменная `obj`. Новый объект целочисленного типа создан не был, но была создана новая ссылка на объект, которая была связана с переменной `obj`. С помощью этой переменной в теле функции мы можем иметь доступ к существующему объекту.

Понять концепцию того, что Python передает объекты в функцию по ссылке, не создавая новый объект - достаточно важно. Особенно это важно, чтобы избежать ошибок с изменением значений объектов изменяемых типов данных в теле функций. Но об этом мы поговорим в основной части курса.

[[К содержанию](#числа-и-функции)]

## Параметры по умолчанию

В процессе определения функции вы также можете указать некоторые параметры в качестве параметров по умолчанию. Для того, чтобы указать параметр параметром по умолчанию, необходимо связать с параметром некоторое значение в момент определения функции:

```python
def function_identifier(param1: int , param2: int = 5) -> int:
    ...
```

В данном примере мы определили функцию с двумя параметрами. `param1` - позиционный параметр, и значение для него должно передаваться при каждом вызове функции. А вот параметр `param2` - это параметр со значением по умолчанию. При вызове функции вы можете передать этот параметр, а можете опустить его, в этом случае будет использовано значением по умолчанию, т.е. `5`. Рассмотрим примеры допустимых вызовов:

```python
# param1 == 1, param2 == 2
function_identifier(1, 2)

# param1 == 3, param2 == 5
function_identifier(3)
```

[[К содержанию](#числа-и-функции)]

## Аннотации типов

В примерах выше мы видели использование аннотаций типов. Параметры функции аннотировались через `:`, за которым следовало имя ожидаемого типа. Возвращаемое значение функции аннотировалось с помощью последовательности `->`. Аннотации типов являются метаинформацией. Т.е. это информация, которая не используется интерпретатором. Параметр, аннотированный, как `int`, может быть связан со строкой, и интерпретатор никак на это не отреагирует.

*Пример игнорирования аннотаций*:
```python
def print_number(num: int) -> None:
    print(f"{num = }")

print_number(num="123")
```

Аннотации типов используются IDE для статического анализа и подсказок. Также аннотации типов используются для увеличения читабельности вашего кода. При работе в команде другим разработчикам будет гораздо проще читать ваши функции, если они будут видеть, какого типа аргументы обрабатывает ваша функция, и какого типа результат она возвращает.

[[К содержанию](#числа-и-функции)]

## return

Все функции, которые мы рассматривали до этого явно не возвращали никакого значения. На самом деле все функции в Python всегда возвращают какое-либо значение. Поведение по умолчанию - возвращение `None`. `None` возвращается в тех случаях, когда в теле функции не указано явно, какой объект следует вернуть.

```python
def print_object_id(obj: object) -> None:
    obj_id = id(obj)
    print(f"{obj_id = }")

print(print_object_id(5))
# obj_id = 140706553521064
# None
```

В данном примере мы никак не определяли, какое значение должна вернуть функция, но при этом явно видно, что функция вернула `None`.

Однако такое поведение не всегда является полезным. В большом количестве случае мы хотим, чтобы функция возвращала осмысленный результат вызывающей стороне. Для этого существует инструкция `return`. На той же строке после инструкции `return` может следовать объект, который мы хотим вернуть вызывающей стороне. Если после `return` не следует никакого объекта, функция будет возвращать `None`. После выполнения инструкции `return` выполнение функции завершается. Код, расположенный после инструкции `return` выполнен не будет. Проиллюстрируем это примером:

```python
def print_number(num: int) -> int:
    print(f"{num = }")
    return num
    print("This message will never be printed")

num = print_number(5)
# num = 5
```
[[К содержанию](#числа-и-функции)]

## min и max

В завершении рассмотрим пару полезный встроенных функций для работы с числами. Функции `min()` и `max()` - функции для определения максимального и минимального значения в последовательности. В общем случае функции поддерживают выполнение с аргументами, для которых определено отношение порядка, но для нас с вами достаточно знать, что эти функции умеют работать с последовательностями чисел:

```python
min(1, 2)               # == 1
max(1, 2)               # == 2
min(-1, 5, 8, -18)      # == -18
max(-1, 5, 8, -18)      # == 8
```

[[К содержанию](#числа-и-функции)]
